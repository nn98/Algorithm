# Greedy
* * *

| **문제**                 | **랭크** | **풀이**                                                                                                                                                                                                                                                                                                                                                                                                                              |                                                                           **비고**                                                                           |
|------------------------|--------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|:----------------------------------------------------------------------------------------------------------------------------------------------------------:|
| [15889](./P15889.py)   | S3     | 알고리즘 분류에 스위핑 떠있어서 감이옴  <br>히스토그램 넘어트리는 문제였나 도미노였나  <br>닿을 수 있는 최대 거리 계산  <br>- 다음 목표까지 가능 ?  <br>- 남은 거리 VS 지금자리에서 출발  <br>반복                                                                                                                                                                                                                                                                                                       |                                                                                                                                                            |
| [11497](./P11497.py)   | S1     | 0, 1, ... n-1, 0  <br>0번 인덱스와 n-1번 인덱스가 인접한 원?형 배열  <br>차이값 최소 == 정렬한 순서대로  <br>선형 배열을 원?형 배열로 배치한다는 발상  <br>정렬된 순서대로 맨 앞/맨 뒤에 하나씩 배치                                                                                                                                                                                                                                                                                               |                              ![이미지](https://velog.velcdn.com/images/nn98/post/b3ff8a18-5a3d-4e98-b17a-3079069f4714/image.png)                              |
| [11000](./P11000.py)   | G5     | `정 렬`  <br>그리디는 기본적으로 효과적인 정렬이 가장 중요한듯<br>정렬을 제대로해줘야 선택 알고리즘이 <br>최선의 선택을 보장 가능 <br>시작 시간 / 종료 시간 오름차순 정렬<br/>→ 동일 시작시간은 종료시간 빠른순<br/>→ 종료시간 무조건 삽입, 조건에 따라 큐 상단 종료시간 poll<br/>→ 삽입은 종료시간, 비교는 시작시간<br/>→ 큐 상단 종료시간 <= 시작시간 → 같은 강의실 사용<br/>→ == 큐 상단값 제거<br/>→ 시작시간이 상단 종료시간보다 빠르면 신규강의실 추가(not poll)<br/>→ 강의실을 큐에 추가 / 이전 강의 종료시 재사용<br/>→ 총 강의실 수 == 큐에 남아있는 값 개수                                                               |                               ![](https://velog.velcdn.com/images/nn98/post/0a24e993-5b73-49bf-98b7-2b7744fc514b/image.png)                                |
| [2212](./P2212.py)     | G5     | `정렬과 규칙`<br/>`Greedy 알고리즘은 각각의 선택이 최선의 선택임을 보장`<br/>문제의 조건에 맞춰 도식화<br/>→ `최선의 선택`을 생각하며 규칙성 탐색<br/>이번 문제의 경우 각 센서의 위치를 일직선으로 도식화(정렬)<br/>→ 최소 가수신 영역 == 센서간 거리 최소화<br/>→ 큰 거리들을 제끼면 되지 않을까<br/>→ 센서간 거리 계산하는 dist 배열, 크기순 정렬<br/>→ 집중국 2개 == 2개의 수신 영역 == 수신 영역을 한 번 끊을 수 있음<br/>→ 집중국 개수-1개만큼 끊을 수 있으므로 가장 긴 거리를 끊어낸다<br/>→ dist배열 최대값 T-1개만큼 삭제<br/>→ 정답                                                                          |                                                                                                                                                            |
| [1092](./P1092.py)     | G5     | `개선 가능성?`<br/>똑같이 일반적인 Greedy<br/>크레인/박스 무게 내림차순 정렬<br/>→ 이동 가능한 최대 크기 순서대로 배열에서 제거<br/>→ 크레인 무게 초과 박스 있으면 -1<br/>→ 박스 배열 비었으면 제거한 횟수 출력<br/>→ 정답                                                                                                                                                                                                                                                                                   |                                                                                                                                                            |
| [1041](./P1041.py)     | G5     | `수학`<br/>수포자에게 이런 시련을<br/>3면이 몇개인지<br/>+ 2면이 몇개인지<br/>+ 1면이 몇개인지<br/>계산, 각 면의 합 최소값 계산해서 두개 곱연산<br/>계산된 값들 합 == 정답                                                                                                                                                                                                                                                                                                                  |                                                                                                                                                            |
| [32407](./P32407.py)   | G4     | `규칙성`<br/>쉬운문제다보니 규칙성만 찾으면 정답<br/>1일짜리는 1개당 하루 그대로 ans += 1day<br/>단순히 확장해서 생각해보면 2일짜리 2개를 살리는데 하루<br/>그대로 계속 확장하면 규칙성이 보임<br/>그걸 식으로 표현하면?<br/>그냥 개수 / 날짜 == 정답<br/>+ 나누어 떨어지지 않는 수들은? <br/>→ 2일짜리 == 1/2 4일짜리 == 1/4 ... <br/>→ 1을 못채우는 화분들은 하루만에 가능<br/>→ 개수 / 날짜 올림하면 정답                                                                                                                                                        |               ![](https://pplx-res.cloudinary.com/image/upload/v1748310534/gpt4o_images/ksq0d6f8ikjiccu2afil.png)<br/>`2 4 4 화분 물주기 패턴 도식화`                |
| [2812](./P2812_C.java) | G3     | `구상을 구현`<br/>정렬은 오름차순이든 내림차순이든<br/>정해진 규칙에 맞춰 숫자의 줄을 세우는 것<br/>여기서 정답은 큰 수니까 내림차순으로 정렬되도록<br/>근데 위치를 스왑하는게 아닌<br/>값을 제거하는 문제니 약간 다른 정렬<br/>→ 제일 앞 자리수가 클수록 결과는 최대화<br/>→ 없앨 수 있는 만큼 작은 수를 없애면서<br/>→ 가장 큰 값이 가장 앞으로 가게<br/>→ k만큼 다 없앴으면 나머진 그냥 추가                                                                                                                                                                                   |                        ![](https://pplx-res.cloudinary.com/image/upload/v1748314568/gpt4o_images/h0tfpsnxgaq3qecuoc6k.png)`잘? 만드네`                         |
| [13904](./P13904.py)   | G3     | `정렬 기준`<br/>어떤 기준으로 정렬해서 <br/>어떤 기준으로 사용할지<br/>모든 과제는 하루가 걸림<br/>점수의 최대값 선택이 1순위.<br/>같은 점수의 과제의 경우<br/>→ 데드라인이 2일 / 3일일 때<br/>→ 3일 과제를 2일에도 풀 수 있지만 굳이?<br/>→ 제일 늦은 데드라인에 맞춰 과제 수행하되<br/>→ 그 데드라인보다 이른 시간에도 수행 가능하므로<br/>→ 점수가 큰 순서대로, 늦은 데드라인 기준으로 과제 수행<br/>→ 과제 점수 합하면 <br/>정답                                                                                                                                                  | ![](https://pplx-res.cloudinary.com/image/upload/v1748326231/user_uploads/54081653/99745763-8665-4499-9b7e-727df05e96a0/temp_1748326228711.-430018032.jpg) |
| [1202](./P1202.py)     | G2     | `갓선순위 큐`<br/>자료구조의 위대함과<br/>그걸 설계한 천재의 위대함<br/>가치 기준 내림차순 무게 기준 오름차순<br/>정렬하고 열심히 큐처럼 돌렸지만 바로 시간초과<br/>강의실 배정 문제랑 비슷한가 했는데 가방이 일회용이라는게 차이<br/>`Solve`<br/>- 가방과 보석 무게 기준으로 오름차순 정렬<br/>- 가방에 보석을 넣을 수 있으면(가방>=보석)<br/>- 보석의 가치를 최대 힙에 저장<br/>- 보석무게가 가방 감당무게를 넘어가면(가방<보석)<br/>- 최대힙 루트값을 pop해서 결과에 합산(가방 소모)<br/>- 최적 무게(감당가능한 최대 무게)의 보석을 담아도 후순위 보석들이 힙에 남아있기에 최선의 선택 유지<br/>`값에 -만 붙여도 최소힙이 최대힙이 된다는`<br/>`간단한 생각을 못하는 수포자는 웁니다` |                                                                                                                                                            |

