# Graph
* * *
> ## <a href = "https://www.acmicpc.net/problem/1045"> 1045 <img src="https://static.solved.ac/tier_small/15.svg" width="30" height="20">도로 </a> 
> ### _[source](./P1045_A.py)_ `Graph` / `Greedy` / `MST(Minimal Spanning Tree)` / `Union-Find`
> 문제 설명 == 같은 언어로 외계어하기
>> *연결된 집합*
>> - 해당 집합에 있는 도로만으로 모든 도시 이동 가능<br>
>>
>> _도로 우선순위_
>> - 사전순 오름차순
>> 
>> _연결은 인접 행렬 형태로 입력_
>> -  우선순위에 맞춰 정렬하기 위해 튜플 형태로 변환 후 추출
>> - ```python 
>>   if (i, j) == 'Y': road.append((i,j))
>>   ```
>> _정렬된 도로를 우선순위 큐에 삽입_
>> - 이미 연결된(부모가 같은) 도로는 삽입하지 않되 별도로 남겨놓기 
>>
>> _연결된 도로의 집합 생성_
>> - MST 생성, Union-Find
>>
>> _제시된 조건에 맞춰(m개 도로의 조합) 남은 도로 추가_
>> - 우선순위 큐에 삽입 안하고 남겨놓은 간선 그대로 추가
>> - 정렬된 도로를 순서대로 삽입했기에 기준 준수 가능
>> - 삽입할 때 사이클/연결 여부 확인
>>
>> _0번 도시와 와 다른 부모를 가진 도시가 있을 경우 -1_
>> - 다 연결되지 않았다는 뜻이기에
>> 
>> _각 끝점의 개수 확인 후 출력_
 
> ## <a href = "https://www.acmicpc.net/problem/1167"> 1167 <img src="https://static.solved.ac/tier_small/14.svg" width="30" height="20">트리의 지름 </a>
> ### _[source](./P1167.py)_ `Graph` / `Tree` / `DFS` | `BFS` / `Diameter of Tree`
> 한 발짝만 더 발상하기
>> - 초기 발상
>>  - 트리에 사이클은 없으니 한 점 A에서 전체 거리 구하고<br>`A → B` + `A → C` == `B → C` 아닌가?
>>  - 아님
>> - 모든 정점에서 다 돌리면 정답이야 나오겠지만 딱봐도 시간초과
>> - 힌트는 탐색 두번? ㅇㅎ
>> - 트리의 지름(가장 먼 두 점 사이의 거리)은 정해져 있고,<br>그 지름 위에는 끝점이 아닌 중간 정점이 존재할 것이고,<br>그 정점이 중간에서 왼쪽에 있다면 오른쪽 끝점이 가장 멀고<br>반대의 경우도 왼↔오 차이일 뿐 동일할 것이고,<br>끝점이든 중간점이든 해당 정점에서 가장 먼 거리의 정점은 끝점이다<br>그 끝점에서 가장 먼 거리의 정점 == 반대편 끝점
>> - 탐색 두번 - 정답